\h3{基本协议}

\h4{简介}

设计API的初衷有二：一是前后端可以分离，前后端都用API来互相通信，二是优化缓存设计，把不同生存期、不同更新频率的内容分割开，各自采用不同的缓存策略。

\h5{前后端分离}

前后端分离的本质是数据和呈现的分离，后端关注数据储存，前端关注数据呈现，这样做的好处有很多。

首先，前端关注的是人机交互，是数据的直接呈现者，如果向以往那样由后端提供渲染完成的页面，则会对前端开发带来很大的麻烦。
前端往往需要关注多个平台，而且常常有布局的调整，内容的删减、添加，如果这样的需求统统都需要后端来配合，则代价太大。
而且，往往后端会把页面呈现和事物逻辑混杂在一起，导致后端代码难以维护。

其次，前端通过API读取数据，渲染页面，可以分摊后端的压力，利用用户浏览器的计算能力去呈现代码，这对于论坛这类动态内容为主的网站特别合适
（静态网站则没有这个优势，因为后端只需要要渲染一次），每个用户渲染的都是不同的页面。

再次，用户个性化自己的页面，其他客户端（如手机、平板等）开发需要设计更加专注于客户端的页面，而前后端分离的设计，为实现这些需求提供了方便。

\h5{缓存优化}

缓存优化也是API设计的目标，它的本质是让资源合理的分割。
让数据库方面之储存逻辑关系，API层面则融合了多个数据库的表，按照数据的逻辑关系+生存期和更新频率分割，分割后的数据则可以采用不同的缓存策略去管理，充分利用用户的浏览器缓存和后端缓存。
过去一个页面中包含了各种生存期、各种更新频率的内容，由于都在后端渲染成页面，数据的缓存仅仅依赖数据库和系统的file cache，当同时在线人数上升时，后端前台网页服务器和后台数据库均不堪重负。
而API设计时考虑了把适合不同缓存策略的数据分开，充分利用HTTP提供的客户端缓存，同时也允许后端实现中间表示层的缓存。想必能大大改善系统性能，服务更多的用户。

\h5{使用API的代价}

然而，API也是有缺陷的，最明显的一个，就是它会增加前后端的请求数。过去一个页面等于一个请求+回复，而现在，简单的页面1-2个请求+回复，如果页面比较复杂，可能会有十个以上的请求+回复。这就使得在HTTP报头加入\@Content-Length\@字段显得更加重要了，有了这个字段，浏览器知道目前的请求什么时候已经完成，就可以复用已有的HTTP链接，而不是盲目的新开链接（主流浏览器限制同时的HTTP链接数在2-8个）。

另外，前端的工作量变大了，以往页面渲染的工作是由诸如ASP, PHP这样的HTML预处理语言写的，新一些的框架下，则是有Perl, Python, Ruby等通用脚本语言写的，现在要转为前端用Javascript完成。
先不说javascript那一半命令式一半函数式，还有各种OO范式的坑爹定义（简直和C++有一拼）和相对陡峭的学习曲线，就是要搞定浏览器兼容性也不是很容易的事（好在我们已经放弃IE 8及更早的用户了，有时间水98还没时间装个浏览器吗？）。前端五花八门的应用框架更让开发者头痛，从最简单的HTML + CSS + javascript变成了目前的ivory + jQuery + knockout + Sammy + highlight.js + jsml-jQuery + ml.js +peg.js + browserify + less + uglifyjs + npm...，好在我们现在统一把前端开发环境叫做基于npm包管理的ebony。但是这些ebony的组件就够开发者学上好几天的了。

当然，这样的组件化的好处依然是很明显的，前端可以用更少的代码完成更多的事情，比如写作这个文档，再也不需要去码HTML+CSS了，直接用ebony提供的ML，在文本文件上用少数几个标记，就能排出漂亮的文章。同样，用其他组件开发前端时，开发者可以把注意力放在设计呈现上，而不是投入大量精力去写正确的代码。

API的另一个问题则是API本身，API不仅仅是一个数据抽象层，还涉及到HTTP协议实现，后端实现等问题，应该会有不少的问题存在，好在这些随着开发的深入和设计的成熟会渐渐改善的。

总体来说，API是一个好东西，设计本身的文档化，同时完成了各个组件的分割与专业化实现。

目前API基本遵照REST理念设计，数据传递主要通过JSON表现的内容实体完成，也有不少元数据和控制数据在HTTP报头中完成。任何遵守HTTP的客户端都可以使用API。
